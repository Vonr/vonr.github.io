<!DOCTYPE html>
<html lang="en">

<head>
    <title>Qther's Site</title>
    <meta charset="utf-8" />
    <link rel="icon" href="../favicon.png" />
    <meta name="viewport" content="width=device-width" />
    <meta name="darkreader-lock">
    <meta content="Qther's Site" property="og:title" />
    <meta content="https://vonr.github.io/" property="og:url" />
    
		<link href="../_app/immutable/assets/0.f6f508fa.css" rel="stylesheet">
		<link href="../_app/immutable/assets/fa.95b16411.css" rel="stylesheet">
		<link href="../_app/immutable/assets/ThemeToggle.91c5c161.css" rel="stylesheet">
		<link href="../_app/immutable/assets/4.720da9ef.css" rel="stylesheet">
		<link rel="modulepreload" href="../_app/immutable/entry/start.9057f8af.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/scheduler.6c817c6f.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/singletons.bf4f724b.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/index.e4b0153f.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/control.f5b05b5f.js">
		<link rel="modulepreload" href="../_app/immutable/entry/app.a35abdf1.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/preload-helper.a4192956.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/index.c0515c57.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/0.3475f4fe.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/fa.4f02a059.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/index.ac23d56d.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/index.04ca9c1a.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/ThemeToggle.svelte_svelte_type_style_lang.06333748.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/4.ae35cb2b.js">
</head>

<body data-sveltekit-preload-data="hover"
    class="transition-colors duration-500 bg-white dark:bg-black text-black dark:text-white">
    <div style="display: contents">    <style data-svelte-h="svelte-1rtngcf">nav ul {
            margin-left: 2rem;
            margin-right: 2rem;
        }</style> <style data-svelte-h="svelte-lexy66">h1:not(.no-hl),
        h2:not(.no-hl),
        h3:not(.no-hl) {
            color: #076678;
        }

        .text-col {
            color: black;
        }</style> 
			<script type="application/json" data-sveltekit-fetched data-url="/articles/why-rust.html">{"status":200,"statusText":"","headers":{},"body":"\u003Ch1>Why Rust?\u003C/h1>\n\u003Ch2>Sep 20 2023\u003C/h2>\n\u003Cp>I have used a variety of languages since I first started my foray into programming.\u003C/p>\n\u003Cp>I started with Javascript, learnt Java, hopped to Kotlin, pivoted to Go, and touched on a bunch of other languages along the way.\u003C/p>\n\u003Cp>Despite all my time with these other languages, I find myself routinely reaching for Rust\nfor whatever I am working on.\u003C/p>\n\u003Cp>Rust was a language that I had a lot of trouble picking up.\u003Cbr>\nI attempted learning it 8 times before it finally clicked.\u003Cbr>\nWhat made it so different, and why do I enjoy it?\u003C/p>\n\u003Ch2>The Borrow Checker\u003C/h2>\n\u003Cp>Rust has a system that it calls the borrow checker.\u003Cbr>\nThis program is at the core of Rust, upholding its borrowing rules.\u003C/p>\n\u003Cp>In Rust, when something is passed by value to another function, it is moved out of its original function.\nThis means that you can no longer access it, even after the function is over.\u003C/p>\n\u003Cpre class=\"hljs codeblock\">\u003Ccode>\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">main\u003C/span>() {\n    \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">s\u003C/span> = \u003Cspan class=\"hljs-type\">String\u003C/span>::\u003Cspan class=\"hljs-title function_ invoke__\">from\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;Hello, world!&quot;\u003C/span>);\n\n    \u003Cspan class=\"hljs-title function_ invoke__\">print\u003C/span>(s);\n\n    \u003Cspan class=\"hljs-comment\">// This would be an error, as s has moved into `print`\u003C/span>\n    \u003Cspan class=\"hljs-built_in\">println!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;{s}&quot;\u003C/span>)\n}\n\n\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">print\u003C/span>(s: \u003Cspan class=\"hljs-type\">String\u003C/span>) {\n    \u003Cspan class=\"hljs-built_in\">println!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;{s}&quot;\u003C/span>)\n}\n\u003C/code>\u003C/pre>\n\u003Cp>\u003Ca href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=4cd8bcc42a9e27c8a287a0295b68a362\" target=\"_blank\">Playground\u003C/a>\u003C/p>\n\u003Cp>Of course, this by itself is inconvenient.\u003Cbr>\nThat's why Rust makes heavy use of borrows - creating references to values.\u003C/p>\n\u003Cp>References are split into two distinct types: shared and immutable, and exclusive and mutable.\u003C/p>\n\u003Cp>Mutable references can not coexist with any other reference, regardless of mutability.\u003C/p>\n\u003Cp>As such, you must pick between having as many immutable references to an object as needed,\nor a single mutable reference.\u003C/p>\n\u003Cpre class=\"hljs codeblock\">\u003Ccode>\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">main\u003C/span>() {\n    \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">s\u003C/span> = \u003Cspan class=\"hljs-type\">String\u003C/span>::\u003Cspan class=\"hljs-title function_ invoke__\">from\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;Hello, world!&quot;\u003C/span>);\n\n    \u003Cspan class=\"hljs-comment\">// We give `print` a reference to `s` instead of `s` itself\u003C/span>\n    \u003Cspan class=\"hljs-title function_ invoke__\">print\u003C/span>(&amp;s);\n\n    \u003Cspan class=\"hljs-comment\">// `s` has not been moved out of this function,\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// and is thus still valid.\u003C/span>\n    \u003Cspan class=\"hljs-built_in\">println!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;{s}&quot;\u003C/span>)\n}\n\n\u003Cspan class=\"hljs-comment\">// `print` now takes in reference to a String.\u003C/span>\n\u003Cspan class=\"hljs-comment\">//\u003C/span>\n\u003Cspan class=\"hljs-comment\">// P.S. the type should really be &amp;str since\u003C/span>\n\u003Cspan class=\"hljs-comment\">// we are only interested in the data of\u003C/span>\n\u003Cspan class=\"hljs-comment\">// the string.\u003C/span>\n\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">print\u003C/span>(s: &amp;\u003Cspan class=\"hljs-type\">String\u003C/span>) {\n    \u003Cspan class=\"hljs-built_in\">println!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;{s}&quot;\u003C/span>)\n}\n\u003C/code>\u003C/pre>\n\u003Cp>\u003Ca href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d1c040196f4c5a11c920ad0c9a2874a6\" target=\"_blank\">Playground\u003C/a>\u003C/p>\n\u003Cp>This rule may seem quite arbitrary at first glance, but this simple rule prevents an entire class of bugs,\nsuch as use-after-free and double-free, which may be especially freeing for developers coming from a C or C++ background.\u003C/p>\n\u003Cp>The borrow checker also gives Rust the ability to know when a value can be freed\nstatically at compile-time, making the use of a garbage collector unnecessary and\nallowing the programmer to not have to worry about memory leaks.\u003C/p>\n\u003Cp>That said, Rust also gives you the tools to free (or \u003Ccode>drop\u003C/code>) a value manually as long as you have ownership of it.\u003Cbr>\nIn fact, it is such a simple function you could write it yourself - no compiler magic!\u003C/p>\n\u003Cpre class=\"hljs codeblock\">\u003Ccode>\u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">drop\u003C/span>&lt;T&gt;(_x: T) {}\n\u003C/code>\u003C/pre>\n\u003Cp>\u003Ca href=\"https://doc.rust-lang.org/std/mem/fn.drop.html\" target=\"_blank\">Docs\u003C/a>\u003C/p>\n\u003Cp>If you wish to learn more about what the borrow checker does, I recommend reading\u003Cbr>\n\u003Ca href=\"https://blog.logrocket.com/introducing-the-rust-borrow-checker/\" target=\"_blank\">this article\u003C/a>.\u003C/p>\n\u003Ch2>Enums (Sum Types)\u003C/h2>\n\u003Cp>The borrow checker is really neat, but one of the biggest reasons I love Rust is how\nexpressive the language is, in many ways thanks to its powerful enums.\u003C/p>\n\u003Cp>If you're familiar with algebraic type systems, Rust's enums are sum types,\nand those of you who know what that implies would already be excited about it.\u003C/p>\n\u003Cp>Let's take a look at the \u003Ccode>Option\u003C/code> type.\nThis type exists in the \u003Ca href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" target=\"_blank\">standard library\u003C/a>\nand is defined similarly to this.\u003C/p>\n\u003Cpre class=\"hljs codeblock\">\u003Ccode>\u003Cspan class=\"hljs-keyword\">enum\u003C/span> \u003Cspan class=\"hljs-title class_\">Option\u003C/span>&lt;T&gt; {\n    \u003Cspan class=\"hljs-title function_ invoke__\">Some\u003C/span>(T),\n    \u003Cspan class=\"hljs-literal\">None\u003C/span>,\n}\n\u003C/code>\u003C/pre>\n\u003Cp>It replaces the \u003Ccode>null\u003C/code>s and \u003Ccode>nil\u003C/code>s of other languages and is analogous to the \u003Ccode>Maybe\u003C/code> type in Haskell.\u003C/p>\n\u003Cp>The most obvious advantage of using a sum type to represent &quot;nullable&quot; values is that they are typed, unlike \u003Ccode>null\u003C/code>s in\na few other languages such as Java, where you can pass a \u003Ccode>null\u003C/code> for any argument.\u003C/p>\n\u003Cp>In Rust, you would have to explicitly write that what you are expecting is an \u003Ccode>Option\u003C/code>.\u003Cbr>\nIf you don't, you will simply get a compile error.\u003C/p>\n\u003Cpre class=\"hljs codeblock\">\u003Ccode>\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">foo\u003C/span>(num: \u003Cspan class=\"hljs-type\">Option\u003C/span>&lt;\u003Cspan class=\"hljs-type\">i32\u003C/span>&gt;) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-type\">Option\u003C/span>&lt;\u003Cspan class=\"hljs-type\">i32\u003C/span>&gt; {\n    num.\u003Cspan class=\"hljs-title function_ invoke__\">map\u003C/span>(|num| num * \u003Cspan class=\"hljs-number\">2\u003C/span>)\n}\n\n\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">main\u003C/span>() {\n    \u003Cspan class=\"hljs-built_in\">assert_eq!\u003C/span>(\u003Cspan class=\"hljs-title function_ invoke__\">foo\u003C/span>(\u003Cspan class=\"hljs-literal\">None\u003C/span>), \u003Cspan class=\"hljs-literal\">None\u003C/span>);\n    \u003Cspan class=\"hljs-built_in\">assert_eq!\u003C/span>(\u003Cspan class=\"hljs-title function_ invoke__\">foo\u003C/span>(\u003Cspan class=\"hljs-title function_ invoke__\">Some\u003C/span>(\u003Cspan class=\"hljs-number\">2\u003C/span>)), \u003Cspan class=\"hljs-title function_ invoke__\">Some\u003C/span>(\u003Cspan class=\"hljs-number\">4\u003C/span>));\n}\n\u003C/code>\u003C/pre>\n\u003Cp>\u003Ca href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=89255fd5cb5ab72b62c8ff772e599acc\" target=\"_blank\">Playground\u003C/a>\u003C/p>\n\u003Cp>As shown in the above example, another advantage is that being a type, we can attach methods such as \u003Ccode>map\u003C/code> onto it.\u003C/p>\n\u003Cp>This makes working with optional values more concise and convenient.\u003C/p>\n\u003Cp>Rust also has a \u003Ccode>Result\u003C/code> type which is very similar to \u003Ccode>Option\u003C/code>, replacing exceptions instead of \u003Ccode>null\u003C/code>.\nYou can read more about it \u003Ca href=\"https://doc.rust-lang.org/std/result/enum.Result.html\" target=\"_blank\">here\u003C/a>.\u003C/p>\n\u003Ch2>Traits (Typeclasses)\u003C/h2>\n\u003Cp>If you've had experience with the ML family of langauges or Haskell, you would be familiar with the concept of typeclasses.\u003C/p>\n\u003Cp>Rust was influenced by Haskell's typeclasses, resulting in traits.\u003C/p>\n\u003Cp>Traits allow us to compartmentalize behaviour into interface-like structures.\u003C/p>\n\u003Cp>We can implement any number of traits for an enum or struct.\u003Cbr>\nWe can also implement foreign traits for our own types, or our own traits for foreign types.\u003C/p>\n\u003Cpre class=\"hljs codeblock\">\u003Ccode>\u003Cspan class=\"hljs-keyword\">trait\u003C/span> \u003Cspan class=\"hljs-title class_\">Legged\u003C/span> {\n    \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">legs\u003C/span>(&amp;\u003Cspan class=\"hljs-keyword\">self\u003C/span>) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-type\">u64\u003C/span>;\n}\n\n\u003Cspan class=\"hljs-keyword\">struct\u003C/span> \u003Cspan class=\"hljs-title class_\">Table\u003C/span> {\n    legs: \u003Cspan class=\"hljs-type\">u64\u003C/span>,\n}\n\n\u003Cspan class=\"hljs-keyword\">struct\u003C/span> \u003Cspan class=\"hljs-title class_\">Chair\u003C/span>;\n\n\u003Cspan class=\"hljs-keyword\">impl\u003C/span> \u003Cspan class=\"hljs-title class_\">Legged\u003C/span> \u003Cspan class=\"hljs-keyword\">for\u003C/span> \u003Cspan class=\"hljs-title class_\">Table\u003C/span> {\n    \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">legs\u003C/span>(&amp;\u003Cspan class=\"hljs-keyword\">self\u003C/span>) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-type\">u64\u003C/span> {\n        \u003Cspan class=\"hljs-keyword\">self\u003C/span>.legs\n    }\n}\n\n\u003Cspan class=\"hljs-keyword\">impl\u003C/span> \u003Cspan class=\"hljs-title class_\">Legged\u003C/span> \u003Cspan class=\"hljs-keyword\">for\u003C/span> \u003Cspan class=\"hljs-title class_\">Chair\u003C/span> {\n    \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">legs\u003C/span>(&amp;\u003Cspan class=\"hljs-keyword\">self\u003C/span>) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-type\">u64\u003C/span> {\n        \u003Cspan class=\"hljs-number\">4\u003C/span>\n    }\n}\n\n\u003Cspan class=\"hljs-comment\">// This function takes in any L such that L implements Legged.\u003C/span>\n\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">has_more_than_3_legs\u003C/span>&lt;L: Legged&gt;(legged: L) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-type\">bool\u003C/span> {\n    legged.\u003Cspan class=\"hljs-title function_ invoke__\">legs\u003C/span>() &gt; \u003Cspan class=\"hljs-number\">3\u003C/span>\n}\n\n\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">main\u003C/span>() {\n    \u003Cspan class=\"hljs-built_in\">assert!\u003C/span>(\u003Cspan class=\"hljs-title function_ invoke__\">has_more_than_3_legs\u003C/span>(Chair));\n    \u003Cspan class=\"hljs-built_in\">assert!\u003C/span>(!\u003Cspan class=\"hljs-title function_ invoke__\">has_more_than_3_legs\u003C/span>(Table { legs: \u003Cspan class=\"hljs-number\">3\u003C/span> }))\n}\n\u003C/code>\u003C/pre>\n\u003Cp>\u003Ca href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=0c7470eeff0dd17b784d38d27eb75507\" target=\"_blank\">Playground\u003C/a>\u003C/p>\n\u003Cp>In the above example, the function \u003Ccode>has_more_than_3_legs\u003C/code> has a simple generic bound, but typeclasses let us express\nmuch more complex bounds.\u003C/p>\n\u003Cpre class=\"hljs codeblock\">\u003Ccode>\u003Cspan class=\"hljs-keyword\">use\u003C/span> std::ops::Add;\n\u003Cspan class=\"hljs-keyword\">use\u003C/span> std::fmt::Display;\n\n\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">double_and_print\u003C/span>&lt;T: Add&lt;Output = T&gt; + Display + \u003Cspan class=\"hljs-built_in\">Clone\u003C/span>&gt;(val: T) {\n    \u003Cspan class=\"hljs-built_in\">println!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;{}&quot;\u003C/span>, val.\u003Cspan class=\"hljs-title function_ invoke__\">clone\u003C/span>() + val)\n}\n\n\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">main\u003C/span>() {\n    \u003Cspan class=\"hljs-title function_ invoke__\">double_and_print\u003C/span>(\u003Cspan class=\"hljs-number\">2\u003C/span>); \u003Cspan class=\"hljs-comment\">// prints &quot;4&quot;\u003C/span>\n}\n\u003C/code>\u003C/pre>\n\u003Cp>\u003Ca href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=ccf2621556e0fe53957be7c9f89938db\" target=\"_blank\">Playground\u003C/a>\u003C/p>\n\u003Cp>There are also alternative syntaxes to specify bounds.\nFor longer bounds like that of \u003Ccode>double_and_print\u003C/code>, we can use the \u003Ccode>where\u003C/code> keyword to specify the bounds after the arguments.\u003C/p>\n\u003Cpre class=\"hljs codeblock\">\u003Ccode>\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">double_and_print\u003C/span>&lt;T&gt;(val: T)\n\u003Cspan class=\"hljs-keyword\">where\u003C/span>\n    T: Add&lt;Output = T&gt; + Display + \u003Cspan class=\"hljs-built_in\">Clone\u003C/span>\n{\n    \u003Cspan class=\"hljs-built_in\">println!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;{}&quot;\u003C/span>, val.\u003Cspan class=\"hljs-title function_ invoke__\">clone\u003C/span>() + val)\n}\n\u003C/code>\u003C/pre>\n\u003Cp>For shorter bounds, we can use the \u003Ccode>impl\u003C/code> keyword inside the arguments themselves, but this would prevent us from specifying\nthe generic type(s) if type inference falls short.\u003C/p>\n\u003Cpre class=\"hljs codeblock\">\u003Ccode>\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">debug\u003C/span>(val: \u003Cspan class=\"hljs-keyword\">impl\u003C/span> \u003Cspan class=\"hljs-title class_\">Display\u003C/span>) {\n    \u003Cspan class=\"hljs-built_in\">println!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;{val}&quot;\u003C/span>)\n}\n\u003C/code>\u003C/pre>\n\u003Cp>Rust has a lot of small conveniences like this, making it both flexible and pleasant to use.\u003C/p>\n\u003Cp>You can also use dynamic dispatch to make a &quot;trait object&quot; type.\u003C/p>\n\u003Cp>It should be noted that trait objects are unsized as different implementors of the trait may have different sizes.\u003Cbr>\nAs such, we put them on the heap using the \u003Ccode>Box\u003C/code> smart pointer and store them in a heap-allocated \u003Ccode>Vec\u003C/code>.\u003C/p>\n\u003Cpre class=\"hljs codeblock\">\u003Ccode>\u003Cspan class=\"hljs-keyword\">use\u003C/span> std::fmt::\u003Cspan class=\"hljs-built_in\">Debug\u003C/span>;\n\n\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">main\u003C/span>() {\n    \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">vec\u003C/span>: \u003Cspan class=\"hljs-type\">Vec\u003C/span>&lt;\u003Cspan class=\"hljs-type\">Box\u003C/span>&lt;\u003Cspan class=\"hljs-keyword\">dyn\u003C/span> \u003Cspan class=\"hljs-built_in\">Debug\u003C/span>&gt;&gt; = \u003Cspan class=\"hljs-built_in\">vec!\u003C/span>[\n        \u003Cspan class=\"hljs-type\">Box\u003C/span>::\u003Cspan class=\"hljs-title function_ invoke__\">new\u003C/span>(\u003Cspan class=\"hljs-number\">1\u003C/span>),\n        \u003Cspan class=\"hljs-type\">Box\u003C/span>::\u003Cspan class=\"hljs-title function_ invoke__\">new\u003C/span>(\u003Cspan class=\"hljs-title function_ invoke__\">Some\u003C/span>(\u003Cspan class=\"hljs-number\">3\u003C/span>)), \n        \u003Cspan class=\"hljs-type\">Box\u003C/span>::\u003Cspan class=\"hljs-title function_ invoke__\">new\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;test&quot;\u003C/span>)\n    ];\n    \n    \u003Cspan class=\"hljs-built_in\">println!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;{vec:?}&quot;\u003C/span>)\n}\n\u003C/code>\u003C/pre>\n\u003Cp>\u003Ca href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=05af188547fe84ba81c0aae62f8e2373\" target=\"_blank\">Playground\u003C/a>\u003C/p>\n\u003Ch2>Iterators\u003C/h2>\n\u003Cp>Iterators are by far my favourite feature of Rust, utilizing its powerful type system\nto create a concise and easy way of manipulating data.\u003C/p>\n\u003Cp>Most collection types in Rust either have an \u003Ccode>iter\u003C/code> method or implement \u003Ccode>IntoIterator\u003C/code>,\nwhich craetes an \u003Ccode>Iterator\u003C/code> over them.\u003C/p>\n\u003Cp>Once in an \u003Ccode>Iterator\u003C/code>, you get access to a wide variety of helper methods to manipulate it\nsuch as \u003Ccode>filter\u003C/code>, \u003Ccode>map\u003C/code>, \u003Ccode>skip\u003C/code>, and \u003Ccode>take\u003C/code> among many more.\u003C/p>\n\u003Cp>Rust's \u003Ccode>Iterator\u003C/code> is &quot;lazy&quot;, meaning that operations on them only run when needed.\nThis avoids allocating a container for each operation, which would be necessary in a strict API.\u003C/p>\n\u003Cpre class=\"hljs codeblock\">\u003Ccode>\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">main\u003C/span>() {\n    \u003Cspan class=\"hljs-comment\">// This is a bad use of `map`, `inspect` is more suitable here.\u003C/span>\n    \u003Cspan class=\"hljs-keyword\">for\u003C/span> \u003Cspan class=\"hljs-variable\">_\u003C/span> \u003Cspan class=\"hljs-keyword\">in\u003C/span> (\u003Cspan class=\"hljs-number\">1\u003C/span>..=\u003Cspan class=\"hljs-number\">10\u003C/span>).\u003Cspan class=\"hljs-title function_ invoke__\">map\u003C/span>(|n| \u003Cspan class=\"hljs-built_in\">println!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;{n}&quot;\u003C/span>)).\u003Cspan class=\"hljs-title function_ invoke__\">take\u003C/span>(\u003Cspan class=\"hljs-number\">3\u003C/span>) {\n        \u003Cspan class=\"hljs-comment\">// Draining the iterator, as it would\u003C/span>\n        \u003Cspan class=\"hljs-comment\">// otherwise be lazy and do nothing.\u003C/span>\n    }\n    \u003Cspan class=\"hljs-comment\">// By the end of the loop,\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// we&#x27;d have printed\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// next 1\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// next 2\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// next 3\u003C/span>\n}\n\u003C/code>\u003C/pre>\n\u003Cp>\u003Ca href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b9b5ff8b9c9b56e5bb6224efba7eae19\" target=\"_blank\">Playground\u003C/a>\u003C/p>\n\u003Cp>Notice how we only printed &quot;next&quot; three times, despite the \u003Ccode>inspect\u003C/code> taking place before \u003Ccode>take\u003C/code>.\u003C/p>\n\u003Cp>The \u003Ccode>Iterator\u003C/code> we produced is equivalent to the following imperative code.\u003C/p>\n\u003Cpre class=\"hljs codeblock\">\u003Ccode>\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-keyword\">mut \u003C/span>\u003Cspan class=\"hljs-variable\">count\u003C/span> = \u003Cspan class=\"hljs-number\">0\u003C/span>;\n\u003Cspan class=\"hljs-keyword\">for\u003C/span> \u003Cspan class=\"hljs-variable\">n\u003C/span> \u003Cspan class=\"hljs-keyword\">in\u003C/span> (\u003Cspan class=\"hljs-number\">1\u003C/span>..=\u003Cspan class=\"hljs-number\">10\u003C/span>) {\n    \u003Cspan class=\"hljs-comment\">// Shadowing the binding of `n` to the result of the map.\u003C/span>\n    \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">n\u003C/span> = \u003Cspan class=\"hljs-built_in\">println!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;{n}&quot;\u003C/span>);\n\n    count += \u003Cspan class=\"hljs-number\">1\u003C/span>;\n    \u003Cspan class=\"hljs-keyword\">if\u003C/span> count &gt;= \u003Cspan class=\"hljs-number\">3\u003C/span> {\n        \u003Cspan class=\"hljs-keyword\">break\u003C/span>\n    }\n\n    \u003Cspan class=\"hljs-comment\">// inner loop\u003C/span>\n}\n\u003C/code>\u003C/pre>\n\u003Cp>While doing the same in Javascript would lead to the equivalent of the following instead,\nnot only unexpectedly printing all 10 numbers, but also allocating two new arrays.\u003C/p>\n\u003Cpre class=\"hljs codeblock\">\u003Ccode>\u003Cspan class=\"hljs-keyword\">let\u003C/span> mapped = [];\n\n\u003Cspan class=\"hljs-keyword\">for\u003C/span> (n \u003Cspan class=\"hljs-keyword\">of\u003C/span> [\u003Cspan class=\"hljs-number\">1\u003C/span>, \u003Cspan class=\"hljs-number\">2\u003C/span>, \u003Cspan class=\"hljs-number\">3\u003C/span>, \u003Cspan class=\"hljs-number\">4\u003C/span>, \u003Cspan class=\"hljs-number\">5\u003C/span>, \u003Cspan class=\"hljs-number\">6\u003C/span>, \u003Cspan class=\"hljs-number\">7\u003C/span>, \u003Cspan class=\"hljs-number\">8\u003C/span>, \u003Cspan class=\"hljs-number\">9\u003C/span>, \u003Cspan class=\"hljs-number\">10\u003C/span>]) {\n    mapped.\u003Cspan class=\"hljs-title function_\">push\u003C/span>(\u003Cspan class=\"hljs-variable language_\">console\u003C/span>.\u003Cspan class=\"hljs-title function_\">log\u003C/span>(n));\n}\n\n\u003Cspan class=\"hljs-keyword\">let\u003C/span> taken = mapped.\u003Cspan class=\"hljs-title function_\">slice\u003C/span>(\u003Cspan class=\"hljs-number\">0\u003C/span>, \u003Cspan class=\"hljs-number\">3\u003C/span>);\n\n\u003Cspan class=\"hljs-keyword\">for\u003C/span> (n \u003Cspan class=\"hljs-keyword\">of\u003C/span> taken) {\n    \u003Cspan class=\"hljs-comment\">// inner loop\u003C/span>\n}\n\u003C/code>\u003C/pre>\n\u003Cp>In my experience, I have never encountered a situation where I'd rather have a strict API here,\nand Rust's lack of container allocations makes it the better option for me.\u003C/p>\n\u003Ch1>Conclusion\u003C/h1>\n\u003Cp>I have only discussed a small portion of the reasons that I love using Rust, but the\nreasons I have discussed are the primary reasons why I continue to choose Rust for\nmany of my projects.\u003C/p>\n\u003Cp>With all that said, I believe it is worth nothing that Rust is neither a perfect langauge\nnor a language that should be used for everything.\u003C/p>\n\u003Cp>In fact, I considered writing this website in Rust for fun, but decided against it in the\nend as I would be losing out on the fantastic Javascript ecosystem which could help\nme push out this website faster.\u003C/p>\n\u003Cp>I believe that Rust deserves a spot on your toolbelt, so that you can easily\nharness it's powers when it fits the project. I personally make a lot of\ncommand-line utilities, which I believe Rust to be an excellent choice for.\u003C/p>\n\u003Cp>If you are interested in learning Rust, I strongly recommend reading the \u003Ca href=\"https://doc.rust-lang.org/book\" target=\"_blank\">Book\u003C/a>\nor doing \u003Ca href=\"https://github.com/rust-lang/rustlings\" target=\"_blank\">Rustlings exercises\u003C/a>.\u003C/p>\n"}</script>
			<script>
				{
					__sveltekit_1ehc2ij = {
						base: new URL("..", location).pathname.slice(0, -1),
						env: {}
					};

					const element = document.currentScript.parentElement;

					const data = [null,null];

					Promise.all([
						import("../_app/immutable/entry/start.9057f8af.js"),
						import("../_app/immutable/entry/app.a35abdf1.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 4],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
</body>

</html>
